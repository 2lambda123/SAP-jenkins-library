package cmd

import (
	"fmt"
	pkgutil "github.com/GoogleContainerTools/container-diff/pkg/util"
	piperDocker "github.com/SAP/jenkins-library/pkg/docker"
	piperhttp "github.com/SAP/jenkins-library/pkg/http"
	"github.com/stretchr/testify/assert"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
	"testing"
)

var malwareScanConfig = malwareExecuteScanOptions{
	Host:     "https://example.org/malwarescanner",
	Username: "me",
	Password: "********",
	ScanFile: "target/myFile",
	Timeout:  "60",
}

type malwareScanUtilsMockBundle struct {
	httpClient *httpMock
}

func (msumb *malwareScanUtilsMockBundle) newHttpClient(options piperhttp.ClientOptions) piperhttp.Sender {
	msumb.httpClient.SetOptions(options)
	return msumb.httpClient
}

func (msumb *malwareScanUtilsMockBundle) newDockerClient(options piperDocker.ClientOptions) piperDocker.Download {
	return &dockerClientMock{imageName: options.ImageName, registryURL: options.RegistryURL, localPath: options.LocalPath, includeLayers: options.IncludeLayers}
}

func TestMalwareScanTests(t *testing.T) {

	open = openFileMock()

	getSHA256 = func(path string) (string, error) {
		return "96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85", nil
	}
	defer func() {
		open = _open
		getSHA256 = _getSHA256
	}()

	t.Run("No malware, no encrypted content in file", func(t *testing.T) {
		httpClient := &httpMock{StatusCode: 200, ResponseBody: "{\"malwareDetected\":false,\"encryptedContentDetected\":false,\"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\"}"}

		utils := malwareScanUtilsMockBundle{
			httpClient: httpClient,
		}

		error := runMalwareScan(&malwareScanConfig, nil, &utils)

		if assert.NoError(t, error) {

			t.Run("check url", func(t *testing.T) {
				assert.Equal(t, "https://example.org/malwarescanner/scan", httpClient.URL)
			})

			t.Run("check method", func(t *testing.T) {
				assert.Equal(t, "POST", httpClient.Method)
			})

			t.Run("check user", func(t *testing.T) {
				assert.Equal(t, "me", httpClient.Options.Username)
			})

			t.Run("check password", func(t *testing.T) {
				assert.Equal(t, "********", httpClient.Options.Password)
			})
		}
	})

	t.Run("No malware detected in docker image", func(t *testing.T) {
		httpClient := &httpMock{StatusCode: 200, ResponseBody: "{\"malwareDetected\":false,\"encryptedContentDetected\":false,\"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\"}"}

		utils := malwareScanUtilsMockBundle{
			httpClient: httpClient,
		}

		malwareScanConfig := malwareExecuteScanOptions{
			Host:      "https://example.org/malwarescanner",
			Username:  "me",
			Password:  "********",
			Timeout:   "60",
			BuildTool: "docker",
			ScanImage: "dockerimagename:latest",
		}

		error := runMalwareScan(&malwareScanConfig, nil, &utils)

		assert.NoError(t, error)
	})

	t.Run("Malware detected in file", func(t *testing.T) {
		utils := malwareScanUtilsMockBundle{
			httpClient: &httpMock{StatusCode: 200, ResponseBody: "{\"malwareDetected\":true,\"encryptedContentDetected\":false,\"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\"}"},
		}
		error := runMalwareScan(&malwareScanConfig, nil, &utils)
		assert.EqualError(t, error, "Malware scan failed for file 'target/myFile'. Malware detected: true, encrypted content detected: false")
	})

	t.Run("Encrypted content detected in file", func(t *testing.T) {
		utils := malwareScanUtilsMockBundle{
			httpClient: &httpMock{StatusCode: 200, ResponseBody: "{\"malwareDetected\": false, \"encryptedContentDetected\": true, \"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\"}"},
		}
		error := runMalwareScan(&malwareScanConfig, nil, &utils)
		assert.EqualError(t, error, "Malware scan failed for file 'target/myFile'. Malware detected: false, encrypted content detected: true")
	})

	t.Run("Malware and encrypted content detected in file", func(t *testing.T) {
		utils := malwareScanUtilsMockBundle{
			httpClient: &httpMock{StatusCode: 200, ResponseBody: "{\"malwareDetected\": true, \"encryptedContentDetected\": true, \"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\"}"},
		}
		error := runMalwareScan(&malwareScanConfig, nil, &utils)
		assert.EqualError(t, error, "Malware scan failed for file 'target/myFile'. Malware detected: true, encrypted content detected: true")
	})

	t.Run("No file and no buildtool specified", func(t *testing.T) {
		malwareScanConfig := malwareExecuteScanOptions{
			Host:     "https://example.org/malwarescanner",
			Username: "me",
			Password: "********",
			Timeout:  "60",
		}

		error := runMalwareScan(&malwareScanConfig, nil, nil)
		assert.EqualError(t, error, "Please specify a file to be scanned")
	})

}

func TestMalwareScanRequest(t *testing.T) {

	httpClient := &httpMock{StatusCode: 200, ResponseBody: "{\"malwareDetected\":false,\"encryptedContentDetected\":false,\"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\"}"}
	candidate := readCloserMock{Content: "HELLO"}

	malWareScanResponse, err := sendMalwareScanRequest(httpClient, "POST", "https://example.org/malwarescanner", candidate)

	t.Run("Malware - scanRequest - check response body closed", func(t *testing.T) {
		if assert.NoError(t, err) {
			assert.True(t, httpClient.Body.Closed)
		}
	})

	t.Run("Malware - scanRequest - check scan response", func(t *testing.T) {

		if assert.NoError(t, err) {
			assert.False(t, malWareScanResponse.MalwareDetected)
			assert.False(t, malWareScanResponse.EncryptedContentDetected)
			assert.Equal(t, 298782, malWareScanResponse.ScanSize)
			assert.Equal(t, "96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85", malWareScanResponse.SHA256)
		}
	})
}

func TestMalwareMarshalBody(t *testing.T) {

	t.Run("Malware - marshalResponse - body uninitialized", func(t *testing.T) {
		var body []byte
		r, error := marshalResponse(body)
		assert.Nil(t, r)
		assert.EqualError(t, error, "Unmarshalling of response body failed. Body: '': unexpected end of JSON input")
	})
}

func TestMalwareValidateResponse(t *testing.T) {

	t.Run("Malware - validateResponse - HTTP error", func(t *testing.T) {
		r, e := validateResponse(nil, fmt.Errorf("request error"))
		assert.Nil(t, r)
		assert.EqualError(t, e, "HTTP request failed with error: request error. Details: \"\"")
	})
	t.Run("Malware - validateResponse - empty response", func(t *testing.T) {
		r, e := validateResponse(&http.Response{}, fmt.Errorf("request error"))
		assert.Nil(t, r)
		assert.EqualError(t, e, "HTTP request failed with error: request error. Details: \"\"")
	})

	t.Run("Malware - validateResponse - status code 500", func(t *testing.T) {
		mock := responseMock(500, true)
		r, e := validateResponse(mock, nil)
		assert.Nil(t, r)
		assert.True(t, strings.HasPrefix(e.Error(), "Unexpected response code (500)"))
	})

	t.Run("Malware - validateResponse - malwareDetected", func(t *testing.T) {
		mock := responseMock(200, true)
		r, e := validateResponse(mock, nil)
		assert.NotNil(t, r)
		assert.Nil(t, e)
	})

}

func responseMock(code int, malwareDetected bool) *http.Response {
	if malwareDetected {
		return &http.Response{StatusCode: code, Body: &readCloserMock{Content: "{\"malwareDetected\":true,\"encryptedContentDetected\":false,\"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\"}"}}
	}
	return &http.Response{StatusCode: code, Body: &readCloserMock{Content: "{\"malwareDetected\":false,\"encryptedContentDetected\":false,\"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\"}"}}
}

func TestMalwareFileNotFound(t *testing.T) {
	utils := malwareScanUtilsMockBundle{
		httpClient: &httpMock{StatusCode: 200},
	}

	open = func(path string) (io.ReadCloser, error) {
		return nil, fmt.Errorf("open %s: no such file or directory", path)
	}
	defer func() { open = _open }()
	error := runMalwareScan(&malwareScanConfig, nil, &utils)

	assert.Error(t, error, "open target/myFile: no such file or directory")
}

func TestMalwareInternalServerError(t *testing.T) {
	utils := malwareScanUtilsMockBundle{
		httpClient: &httpMock{StatusCode: 500, ResponseBody: "internal server error"},
	}

	open = openFileMock()

	defer func() { open = _open }()

	err := runMalwareScan(&malwareScanConfig, nil, &utils)

	assert.Error(t, err, "Unexpected response code (500). 200 expected. Details: \"internal server error\"")
}

func TestMalwareRetrieveHash(t *testing.T) {

	open = openFileMock()

	defer func() {
		open = _open
	}()
	hash, err := _getSHA256("target/myFile")

	if assert.NoError(t, err) {
		assert.Equal(t, "3733cd977ff8eb18b987357e22ced99f46097f31ecb239e878ae63760e83e4d5", hash)
	}
}

func openFileMock() func(path string) (io.ReadCloser, error) {
	return func(path string) (io.ReadCloser, error) {
		if path == "target/myFile" {
			return &readCloserMock{Content: "HELLO"}, nil // the content does not matter
		} else if path == "dockerimagename_latest.tar" {
			return &readCloserMock{Content: ""}, nil
		}
		return nil, fmt.Errorf("open %s: no such file or directory", path)
	}
}

type httpMock struct {
	Method       string                  // is set during test execution
	URL          string                  // is set before test execution
	ResponseBody string                  // is set before test execution
	Options      piperhttp.ClientOptions // is set during test
	StatusCode   int                     // is set during test
	Body         readCloserMock          // is set during test
}

func (c *httpMock) SetOptions(options piperhttp.ClientOptions) {
	c.Options = options
}

func (c *httpMock) SendRequest(method string, url string, r io.Reader, header http.Header, cookies []*http.Cookie) (*http.Response, error) {
	c.Method = method
	c.URL = url

	_, err := ioutil.ReadAll(r)

	if err != nil {
		return nil, err
	}

	c.Body = readCloserMock{Content: c.ResponseBody}
	res := http.Response{StatusCode: c.StatusCode, Body: &c.Body}

	return &res, nil
}

type readCloserMock struct {
	Content string
	Closed  bool
}

func (rc readCloserMock) Read(b []byte) (n int, err error) {

	if len(b) < len(rc.Content) {
		// in real life we would fill the buffer according to buffer size ...
		return 0, fmt.Errorf("Buffer size (%d) not sufficient, need: %d", len(b), len(rc.Content))
	}
	copy(b, rc.Content)
	return len(rc.Content), io.EOF
}

func (rc *readCloserMock) Close() error {
	rc.Closed = true
	return nil
}

type dockerClientMock struct {
	imageName     string
	registryURL   string
	localPath     string
	includeLayers bool
}

func (c *dockerClientMock) GetImageSource() (string, error) {
	return c.imageName, nil
}

//DownloadImageToPath download the image to the specified path
func (c *dockerClientMock) DownloadImageToPath(imageSource, filePath string) (pkgutil.Image, error) {
	return pkgutil.Image{}, nil // fmt.Errorf("%s", filePath)
}

//TarImage write a tar from the given image
func (c *dockerClientMock) TarImage(writer io.Writer, image pkgutil.Image) error {
	return nil
}
